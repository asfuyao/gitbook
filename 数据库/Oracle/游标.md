<!-- TOC -->

- [1. 游标的使用](#1-游标的使用)
    - [1.1. 游标概念](#11-游标概念)
        - [1.1.1. 处理显式游标](#111-处理显式游标)
            - [1.1.1.1. 定义/声明游标](#1111-定义声明游标)
            - [1.1.1.2. 打开游标](#1112-打开游标)
            - [1.1.1.3. 提取游标数据](#1113-提取游标数据)
            - [1.1.1.4. 对该记录进行处理](#1114-对该记录进行处理)
            - [1.1.1.5. 继续处理，直到活动集合中没有记录](#1115-继续处理直到活动集合中没有记录)
            - [1.1.1.6. 关闭游标](#1116-关闭游标)
        - [1.1.2. 例1. 查询前10名员工的信息](#112-例1-查询前10名员工的信息)
        - [1.1.3. 例2. 游标参数的传递方法](#113-例2-游标参数的传递方法)
        - [1.1.4. 游标属性](#114-游标属性)
        - [1.1.5. 例3：给工资低于1200 的员工增加工资50](#115-例3给工资低于1200-的员工增加工资50)
        - [1.1.6. 例4：没有参数且没有返回值的游标](#116-例4没有参数且没有返回值的游标)
        - [1.1.7. 例5：有参数且没有返回值的游标](#117-例5有参数且没有返回值的游标)
        - [1.1.8. 例6：有参数且有返回值的游标](#118-例6有参数且有返回值的游标)
        - [1.1.9. 例7：基于游标定义记录变量](#119-例7基于游标定义记录变量)
        - [1.1.10. 游标的FOR循环](#1110-游标的for循环)
        - [1.1.11. 例8](#1111-例8)
        - [例10：PL/SQL还允许在游标FOR循环语句中使用子查询来实现游标的功能](#例10plsql还允许在游标for循环语句中使用子查询来实现游标的功能)

<!-- /TOC -->

# 1. 游标的使用

在 PL/SQL 程序中，对于处理多行记录的事务经常使用游标来实现。

## 1.1. 游标概念

&emsp;&emsp;在PL/SQL块中执行SELECT、INSERT、DELETE和UPDATE语句时，ORACLE会在内存中为其分配上下文区（Context Area），即缓冲区。游标是指向该区的一个指针，或是命名一个工作区（Work Area），或是一种结构化数据类型。它为应用等量齐观提供了一种对具有多行数据查询结果集中的每一行数据分别进行单独处理的方法，是设计嵌入式SQL语句的应用程序的常用编程方式。

&emsp;&emsp;在每个用户会话中，可以同时打开多个游标，其数量由数据库初始化参数文件中的OPEN_CURSORS参数定义。

对于不同的SQL语句，游标的使用情况不同：

| SQL语句 | 游标 |
| :------| :------ |
| 非查询语句 | 隐式的 |
| 结果是单行的查询语句 | 隐式的或显示的 |
| 结果是多行的查询语句 | 显示的 |

### 1.1.1. 处理显式游标

&emsp;&emsp;显式游标处理需四个 PL/SQL步骤:

#### 1.1.1.1. 定义/声明游标

&emsp;&emsp;就是定义一个游标名，以及与其相对应的`SELECT`语句。

格式：

```sql
CURSOR cursor_name[(parameter[, parameter]…)]
        [RETURN datatype]
IS
    select_statement;
```

&emsp;&emsp;游标参数只能为输入参数，其格式为：

```sql
parameter_name [IN] datatype [{:= | DEFAULT} expression]
```

&emsp;&emsp;**在指定数据类型时，不能使用长度约束。如**`NUMBER(4),CHAR(10)`**等都是错误的。**

&emsp;&emsp;`[RETURN datatype]`是可选的，表示**游标**返回数据的数据。如果选择，则应该严格与`select_statement`中的选择列表在次序和数据类型上匹配。一般是记录数据类型或带“`%ROWTYPE`”的数据。

#### 1.1.1.2. 打开游标

&emsp;&emsp;就是执行游标所对应的`SELECT`语句，将其查询结果放入工作区，并且指针指向工作区的首部，标识游标结果集合。如果游标查询语句中带有`FOR UPDATE`选项，`OPEN`语句还将锁定数据库表中游标结果集合对应的数据行。

格式：

```sql
OPEN cursor_name[([parameter =>] value[, [parameter =>] value]…)];
```

&emsp;&emsp;在向游标传递参数时，可以使用与函数参数相同的传值方法，即位置表示法和名称表示法。PL/SQL程序不能用`OPEN`语句重复打开一个游标。

#### 1.1.1.3. 提取游标数据
&emsp;&emsp;就是检索结果集合中的数据行，放入指定的输出变量中。

格式：

```sql
FETCH cursor_name INTO {variable_list | record_variable };
```

&emsp;&emsp;执行FETCH语句时，每次返回一个数据行，然后自动将游标移动指向下一个数据行。当检索到最后一行数据时，如果再次执行`FETCH`语句，将操作失败，并将游标属性`%NOTFOUND`置为`TRUE`。所以每次执行完`FETCH`语句后，检查游标属性`%NOTFOUND`就可以判断`FETCH`语句是否执行成功并返回一个数据行，以便确定是否给对应的变量赋了值。

#### 1.1.1.4. 对该记录进行处理

#### 1.1.1.5. 继续处理，直到活动集合中没有记录

#### 1.1.1.6. 关闭游标

&emsp;&emsp;当提取和处理完游标结果集合数据后，应及时关闭游标，以释放该游标所占用的系统资源，并使该游标的工作区变成无效，不能再使用`FETCH`语句取其中数据。关闭后的游标可以使用`OPEN`语句重新打开。

格式：

```sql
CLOSE cursor_name;
```

**注：定义的游标不能有INTO 子句。**

### 1.1.2. 例1. 查询前10名员工的信息

```sql
DECLARE
  CURSOR C_CURSOR IS
    SELECT FIRST_NAME || LAST_NAME, SALARY
      FROM EMPLOYEES
     WHERE ROWNUM < 11;
  V_ENAME EMPLOYEES.FIRST_NAME%TYPE;
  V_SAL   EMPLOYEES.SALARY%TYPE;
BEGIN
  OPEN C_CURSOR;
  FETCH C_CURSOR
    INTO V_ENAME, V_SAL;
  WHILE C_CURSOR%FOUND LOOP
    DBMS_OUTPUT.PUT_LINE(V_ENAME || '---' || TO_CHAR(V_SAL));
    FETCH C_CURSOR
      INTO V_ENAME, V_SAL;
  END LOOP;
  CLOSE C_CURSOR;
END;
```

### 1.1.3. 例2. 游标参数的传递方法

```sql
DECLARE
  DEPTREC   DEPARTMENTS%ROWTYPE;
  DEPT_NAME DEPARTMENTS.DEPARTMENT_NAME%TYPE;
  DEPT_LOC  DEPARTMENTS.LOCATION_ID%TYPE;
  CURSOR C1 IS
    SELECT DEPARTMENT_NAME, LOCATION_ID
      FROM DEPARTMENTS
     WHERE DEPARTMENT_ID <= 30;

  CURSOR C2(DEPT_NO NUMBER DEFAULT 10) IS
    SELECT DEPARTMENT_NAME, LOCATION_ID
      FROM DEPARTMENTS
     WHERE DEPARTMENT_ID <= DEPT_NO;
  CURSOR C3(DEPT_NO NUMBER DEFAULT 10) IS
    SELECT * FROM DEPARTMENTS WHERE DEPARTMENTS.DEPARTMENT_ID <= DEPT_NO;
BEGIN
  OPEN C1;
  LOOP
    FETCH C1
      INTO DEPT_NAME, DEPT_LOC;
    EXIT WHEN C1%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(DEPT_NAME || '---' || DEPT_LOC);
  END LOOP;
  CLOSE C1;

  OPEN C2;
  LOOP
    FETCH C2
      INTO DEPT_NAME, DEPT_LOC;
    EXIT WHEN C2%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(DEPT_NAME || '---' || DEPT_LOC);
  END LOOP;
  CLOSE C2;

  OPEN C3(DEPT_NO => 20);
  LOOP
    FETCH C3
      INTO DEPTREC;
    EXIT WHEN C3%NOTFOUND;
    DBMS_OUTPUT.PUT_LINE(DEPTREC.DEPARTMENT_ID || '---' ||
                         DEPTREC.DEPARTMENT_NAME || '---' ||
                         DEPTREC.LOCATION_ID);
  END LOOP;
  CLOSE C3;
END;

```

### 1.1.4. 游标属性

- `Cursor_name%FOUND` *布尔型属性，当最近一次提取游标操作`FETCH`成功则为`TRUE`,否则为`FALSE`；*
- `Cursor_name%NOTFOUND` *布尔型属性，与`%FOUND`相反；*
- `Cursor_name%ISOPEN` *布尔型属性，当游标已打开时返回`TRUE`；*
- `Cursor_name%ROWCOUNT` *数字型属性，返回已从游标中读取的记录数。*

### 1.1.5. 例3：给工资低于1200 的员工增加工资50

```sql
 DECLARE
  V_EMPNO EMPLOYEES.EMPLOYEE_ID%TYPE;
  V_SAL   EMPLOYEES.SALARY%TYPE;
  CURSOR C_CURSOR IS
    SELECT EMPLOYEE_ID, SALARY FROM EMPLOYEES;
BEGIN
  OPEN C_CURSOR;
  LOOP
    FETCH C_CURSOR
      INTO V_EMPNO, V_SAL;
    EXIT WHEN C_CURSOR%NOTFOUND;
    IF V_SAL <= 1200 THEN
      UPDATE EMPLOYEES
         SET SALARY = SALARY + 50
       WHERE EMPLOYEE_ID = V_EMPNO;
      DBMS_OUTPUT.PUT_LINE('编码为' || V_EMPNO || '工资已更新!');
    END IF;
    DBMS_OUTPUT.PUT_LINE('记录数:' || C_CURSOR %ROWCOUNT);
  END LOOP;
  CLOSE C_CURSOR;
END;
```

### 1.1.6. 例4：没有参数且没有返回值的游标

```sql
DECLARE
  V_F_NAME EMPLOYEES.FIRST_NAME%TYPE;
  V_J_ID   EMPLOYEES.JOB_ID%TYPE;
  CURSOR C1 --声明游标,没有参数没有返回值
  IS
    SELECT FIRST_NAME, JOB_ID FROM EMPLOYEES WHERE DEPARTMENT_ID = 20;
BEGIN
  OPEN C1; --打开游标
  LOOP
    FETCH C1
      INTO V_F_NAME, V_J_ID; --提取游标
    IF C1%FOUND THEN
      DBMS_OUTPUT.PUT_LINE(V_F_NAME || '的岗位是' || V_J_ID);
    ELSE
      DBMS_OUTPUT.PUT_LINE('已经处理完结果集了');
      EXIT;
    END IF;
  END LOOP;
  CLOSE C1; --关闭游标
END;
```

### 1.1.7. 例5：有参数且没有返回值的游标

```sql
DECLARE
  V_F_NAME EMPLOYEES.FIRST_NAME%TYPE;
  V_H_DATE EMPLOYEES.HIRE_DATE%TYPE;
  CURSOR C2(DEPT_ID NUMBER, J_ID VARCHAR2) --声明游标,有参数没有返回值
  IS
    SELECT FIRST_NAME, HIRE_DATE
      FROM EMPLOYEES
     WHERE DEPARTMENT_ID = DEPT_ID
       AND JOB_ID = J_ID;
BEGIN
  OPEN C2(90, 'AD_VP'); --打开游标,传递参数值
  LOOP
    FETCH C2
      INTO V_F_NAME, V_H_DATE; --提取游标
    IF C2%FOUND THEN
      DBMS_OUTPUT.PUT_LINE(V_F_NAME || '的雇佣日期是' || V_H_DATE);
    ELSE
      DBMS_OUTPUT.PUT_LINE('已经处理完结果集了');
      EXIT;
    END IF;
  END LOOP;
  CLOSE C2; --关闭游标
END;
```

### 1.1.8. 例6：有参数且有返回值的游标

```sql
DECLARE
  TYPE EMP_RECORD_TYPE IS RECORD(
    F_NAME EMPLOYEES.FIRST_NAME%TYPE,
    H_DATE EMPLOYEES.HIRE_DATE%TYPE);
  V_EMP_RECORD EMP_RECORD_TYPE;

  CURSOR C3(DEPT_ID NUMBER, J_ID VARCHAR2) --声明游标,有参数有返回值
  RETURN EMP_RECORD_TYPE IS
    SELECT FIRST_NAME, HIRE_DATE
      FROM EMPLOYEES
     WHERE DEPARTMENT_ID = DEPT_ID
       AND JOB_ID = J_ID;
BEGIN
  OPEN C3(J_ID => 'AD_VP', DEPT_ID => 90); --打开游标,传递参数值
  LOOP
    FETCH C3
      INTO V_EMP_RECORD; --提取游标
    IF C3%FOUND THEN
      DBMS_OUTPUT.PUT_LINE(V_EMP_RECORD.F_NAME || '的雇佣日期是' ||
                           V_EMP_RECORD.H_DATE);
    ELSE
      DBMS_OUTPUT.PUT_LINE('已经处理完结果集了');
      EXIT;
    END IF;
  END LOOP;
  CLOSE C3; --关闭游标
END;
```

### 1.1.9. 例7：基于游标定义记录变量

```sql
DECLARE
  CURSOR C4(DEPT_ID NUMBER, J_ID VARCHAR2) --声明游标,有参数没有返回值
  IS
    SELECT FIRST_NAME F_NAME, HIRE_DATE
      FROM EMPLOYEES
     WHERE DEPARTMENT_ID = DEPT_ID
       AND JOB_ID = J_ID;
  --基于游标定义记录变量，比声明记录类型变量要方便，不容易出错
  V_EMP_RECORD C4%ROWTYPE;
BEGIN
  OPEN C4(90, 'AD_VP'); --打开游标,传递参数值
  LOOP
    FETCH C4
      INTO V_EMP_RECORD; --提取游标
    IF C4%FOUND THEN
      DBMS_OUTPUT.PUT_LINE(V_EMP_RECORD.F_NAME || '的雇佣日期是' ||
                           V_EMP_RECORD.HIRE_DATE);
    ELSE
      DBMS_OUTPUT.PUT_LINE('已经处理完结果集了');
      EXIT;
    END IF;
  END LOOP;
  CLOSE C4; --关闭游标
END;
```

### 1.1.10. 游标的FOR循环

PL/SQL语言提供了游标FOR循环语句，自动执行游标的`OPEN、FETCH、CLOSE`语句和循环语句的功能；当进入循环时，游标`FOR`循环语句自动打开游标，并提取第一行游标数据，当程序处理完当前所提取的数据而进入下一次循环时，游标`FOR`循环语句自动提取下一行数据供程序处理，当提取完结果集合中的所有数据行后结束循环，并自动关闭游标。

格式：

```sql
FOR index_variable IN cursor_name[(value[, value]…)] LOOP
-- 游标数据处理代码
END LOOP;
```

其中：

`index_variable为`游标`FOR`循环语句隐含声明的索引变量，该变量为记录变量，其结构与游标查询语句返回的结构集合的结构相同。在程序中可以通过引用该索引记录变量元素来读取所提取的游标数据，`index_variable`中各元素的名称与游标查询语句选择列表中所制定的列名相同。如果在游标查询语句的选择列表中存在计算列，则必须为这些计算列指定别名后才能通过游标`FOR`循环语句中的索引变量来访问这些列数据。

**注：不要在程序中对游标进行人工操作；不要在程序中定义用于控制`FOR`循环的记录。**

### 1.1.11. 例8

```sql
DECLARE
  CURSOR C_SAL IS
    SELECT EMPLOYEE_ID, FIRST_NAME || LAST_NAME ENAME, SALARY
      FROM EMPLOYEES;
BEGIN
  --隐含打开游标
  FOR V_SAL IN C_SAL LOOP
    --隐含执行一个FETCH语句
    DBMS_OUTPUT.PUT_LINE(TO_CHAR(V_SAL.EMPLOYEE_ID) || '---' ||
                         V_SAL.ENAME || '---' || TO_CHAR(V_SAL.SALARY));
    --隐含监测c_sal%NOTFOUND
  END LOOP;
  --隐含关闭游标
END;
```

### 例10：PL/SQL还允许在游标FOR循环语句中使用子查询来实现游标的功能

```sql
BEGIN
  FOR C1_REC IN (SELECT DEPARTMENT_NAME, LOCATION_ID FROM DEPARTMENTS) LOOP
    DBMS_OUTPUT.PUT_LINE(C1_REC.DEPARTMENT_NAME || '---' || C1_REC.LOCATION_ID);
  END LOOP;
END;
```
